{"version":3,"names":["_url","_interopRequireDefault","require","_common","_constants","_parameter","_loggerProxy","MeetingInfoUtil","getParsedUrl","link","parsedUrl","url","parse","protocol","concat","HTTPS_PROTOCOL","error","LoggerProxy","logger","warn","isMeetingLink","value","hostNameBool","hostname","includes","WEBEX_DOT_COM","pathNameBool","pathname","MEET","MEET_M","JOIN","isConversationUrl","webex","clusterId","internal","services","getClusterId","endsWith","CONVERSATION_SERVICE","isSipUri","sipString","sipUri","DIALER_REGEX","SIP_ADDRESS","exec","isPhoneNumber","phoneNumber","isValidNumber","PHONE_NUMBER","test","getHydraId","destination","_deconstructHydraId","deconstructHydraId","type","id","cluster","UUID_REG","_ROOM_","room","_PEOPLE_","people","getSipUriFromHydraPersonId","get","then","res","emails","length","ParameterError","catch","err","getDestinationType","_ref","_asyncToGenerator2","default","_regenerator","mark","_callee","from","_options","_res$items$","orgId","userId","options","hydraId","conversationUrl","wrap","_callee$","_context","prev","next","_PERSONAL_ROOM_","device","VALID_EMAIL_ADDRESS","email","list","sent","items","abrupt","_MEETING_LINK_","_SIP_URI_","_CONVERSATION_URL_","wasHydraPerson","_promise","resolve","waitForCatalog","conversation","getUrlFromClusterId","t0","stop","_x","apply","arguments","getRequestBody","_destination$info","_destination$info2","password","captchaInfo","body","supportHostKey","supportCountryList","sipUrl","_MEETING_ID_","meetingKey","_LOCUS_ID_","info","webExMeetingId","meetingUrl","_MEETING_UUID_","meetingUUID","captchaID","captchaVerifyCode","code","getWebexSite","uri","_uri$match","exceptedDomains","site","match","getDirectMeetingInfoURI","_destination$info3","preferredWebexSite","webExSite","_default","exports"],"sources":["utilv2.ts"],"sourcesContent":["import url from 'url';\n\nimport {\n  // @ts-ignore\n  deconstructHydraId,\n} from '@webex/common';\n\nimport {\n  _SIP_URI_,\n  _PERSONAL_ROOM_,\n  _MEETING_ID_,\n  _CONVERSATION_URL_,\n  _LOCUS_ID_,\n  _MEETING_LINK_,\n  _PEOPLE_,\n  _ROOM_,\n  _MEETING_UUID_,\n  DIALER_REGEX,\n  WEBEX_DOT_COM,\n  CONVERSATION_SERVICE,\n  JOIN,\n  MEET,\n  MEET_M,\n  HTTPS_PROTOCOL,\n  UUID_REG,\n  VALID_EMAIL_ADDRESS,\n} from '../constants';\nimport ParameterError from '../common/errors/parameter';\nimport LoggerProxy from '../common/logs/logger-proxy';\n\nconst MeetingInfoUtil: any = {};\n\nMeetingInfoUtil.getParsedUrl = (link) => {\n  try {\n    let parsedUrl = url.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    }\n    // hack for links such as <company>.webex.com/meet/<user> without a protocol\n    if (!parsedUrl.protocol) {\n      parsedUrl = url.parse(`${HTTPS_PROTOCOL}${link}`);\n    }\n\n    return parsedUrl;\n  } catch (error) {\n    LoggerProxy.logger.warn(\n      `Meeting-info:util#getParsedUrl --> unable to parse the URL, error: ${error}`\n    );\n\n    return null;\n  }\n};\n\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\nMeetingInfoUtil.isMeetingLink = (value: string) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  const hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(WEBEX_DOT_COM);\n  const pathNameBool =\n    parsedUrl.pathname &&\n    (parsedUrl.pathname.includes(`/${MEET}`) ||\n      parsedUrl.pathname.includes(`/${MEET_M}`) ||\n      parsedUrl.pathname.includes(`/${JOIN}`));\n\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = (value, webex) => {\n  const clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\nMeetingInfoUtil.isSipUri = (sipString) => {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = (phoneNumber) => {\n  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = (destination) => {\n  const {type, id, cluster} = deconstructHydraId(destination);\n\n  if (id && UUID_REG.test(id)) {\n    if (type === _ROOM_) {\n      return {room: true, destination: id, cluster};\n    }\n    if (type === _PEOPLE_) {\n      return {people: true, destination: id, cluster};\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = (destination, webex) =>\n  webex.people\n    .get(destination)\n    .then((res) => {\n      if (res.emails && res.emails.length) {\n        return res.emails[0];\n      }\n      throw new ParameterError('Hydra Id Lookup was an invalid hydra person id.');\n    })\n    .catch((err) => {\n      LoggerProxy.logger.error(\n        `Meeting-info:util#MeetingInfoUtil.getSipUriFromHydraPersonId --> getSipUriFromHydraPersonId ${err} `\n      );\n      throw err;\n    });\n\nMeetingInfoUtil.getDestinationType = async (from) => {\n  const {type, webex} = from;\n  let {destination} = from;\n\n  if (type === _PERSONAL_ROOM_) {\n    // this case checks if your type is personal room\n    if (!destination) {\n      // if we are not getting anything in desination we fetch org and user ids from webex instance\n      destination = {\n        userId: webex.internal.device.userId,\n        orgId: webex.internal.device.orgId,\n      };\n    } else {\n      const options = VALID_EMAIL_ADDRESS.test(destination)\n        ? {email: destination}\n        : {id: destination}; // we are assuming userId as default\n      const res = await webex.people.list(options);\n\n      let {orgId, id: userId} = res.items[0];\n\n      userId = deconstructHydraId(userId).id;\n      orgId = deconstructHydraId(orgId).id;\n      destination = {userId, orgId};\n    }\n  }\n  if (type) {\n    return {\n      destination,\n      type,\n    };\n  }\n  const options: any = {};\n  const hydraId = MeetingInfoUtil.getHydraId(destination);\n\n  if (MeetingInfoUtil.isMeetingLink(destination)) {\n    LoggerProxy.logger.warn(\n      'Meeting-info:util#generateOptions --> WARN, use of Meeting Link is deprecated, please use a SIP URI instead'\n    );\n\n    options.type = _MEETING_LINK_;\n    options.destination = destination;\n  } else if (MeetingInfoUtil.isSipUri(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  } else if (MeetingInfoUtil.isPhoneNumber(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  } else if (MeetingInfoUtil.isConversationUrl(destination, webex)) {\n    options.type = _CONVERSATION_URL_;\n    options.destination = destination;\n  } else if (hydraId.people) {\n    options.type = _SIP_URI_;\n\n    return MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then((res) => {\n      options.destination = res;\n\n      // Since hydra person ids require a unique case in which they are\n      // entirely converted to a SIP URI, we need to set a flag for detecting\n      // this type of destination.\n      options.wasHydraPerson = true;\n\n      return Promise.resolve(options);\n    });\n  } else if (hydraId.room) {\n    options.type = _CONVERSATION_URL_;\n    try {\n      await webex.internal.services.waitForCatalog('postauth');\n\n      const conversationUrl = webex.internal.conversation.getUrlFromClusterId({\n        cluster: hydraId.cluster,\n        id: hydraId.destination,\n      });\n\n      options.destination = conversationUrl;\n    } catch (e) {\n      LoggerProxy.logger.error(`Meeting-info:util#getDestinationType --> ${e}`);\n      throw e;\n    }\n  } else {\n    LoggerProxy.logger.warn(\n      \"Meeting-info:util#getDestinationType --> ('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.\"\n    );\n    throw new ParameterError(\n      'MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.'\n    );\n  }\n\n  return Promise.resolve(options);\n};\n\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {Object} options type and value to fetch meeting info\n * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} options.destination ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\nMeetingInfoUtil.getRequestBody = (options: {type: string; destination: object} | any) => {\n  const {type, destination, password, captchaInfo} = options;\n  const body: any = {\n    supportHostKey: true,\n    supportCountryList: true,\n  };\n\n  switch (type) {\n    case _SIP_URI_:\n      body.sipUrl = destination;\n      break;\n    case _PERSONAL_ROOM_:\n      body.userId = destination.userId;\n      body.orgId = destination.orgId;\n      break;\n    case _MEETING_ID_:\n      body.meetingKey = destination;\n      break;\n    case _CONVERSATION_URL_:\n      body.conversationUrl = destination;\n      break;\n    case _LOCUS_ID_:\n      // use meetingID for the completer meeting info for the already started meeting\n      if (destination.info?.webExMeetingId) {\n        body.meetingKey = destination.info.webExMeetingId;\n      } else if (destination.info?.sipUri) {\n        body.sipUrl = destination.info.sipUri;\n      }\n      break;\n    case _MEETING_LINK_:\n      body.meetingUrl = destination;\n      break;\n    case _MEETING_UUID_: {\n      body.meetingUUID = destination;\n      break;\n    }\n    default:\n  }\n\n  if (password) {\n    body.password = password;\n  }\n\n  if (captchaInfo) {\n    body.captchaID = captchaInfo.id;\n    body.captchaVerifyCode = captchaInfo.code;\n  }\n\n  return body;\n};\n\n/**\n * Helper function to parse the webex site/host from a URI string.\n * @param {String} uri string (e.g. '10019857020@convergedats.webex.com')\n * @returns {String} the site/host part of the URI string (e.g. 'convergedats.webex.com')\n */\nMeetingInfoUtil.getWebexSite = (uri: string) => {\n  const exceptedDomains = ['meet.webex.com', 'meetup.webex.com', 'ciscospark.com'];\n  const site = uri?.match(/.+@([^.]+\\.[^.]+\\.[^.]+)$/)?.[1];\n\n  return exceptedDomains.includes(site) ? null : site;\n};\n\n/**\n * Helper function to return the direct URI for fetching meeting info (to avoid a redirect).\n * @param {Object} options type and value to fetch meeting info\n * @param {String} options.type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} options.destination ?? value.value\n * @returns {String} returns a URI string or null of there is no direct URI\n */\nMeetingInfoUtil.getDirectMeetingInfoURI = (options: {type: string; destination: any}) => {\n  const {type, destination} = options;\n\n  let preferredWebexSite = null;\n\n  switch (type) {\n    case _SIP_URI_:\n      preferredWebexSite = MeetingInfoUtil.getWebexSite(destination);\n      break;\n    case _LOCUS_ID_:\n      preferredWebexSite = destination.info?.webExSite;\n      break;\n    default:\n  }\n\n  return preferredWebexSite ? `https://${preferredWebexSite}/wbxappapi/v1/meetingInfo` : null;\n};\n\nexport default MeetingInfoUtil;\n"],"mappings":";;;;;;;;;;;AAAA,IAAAA,IAAA,GAAAC,sBAAA,CAAAC,OAAA;AAEA,IAAAC,OAAA,GAAAD,OAAA;AAKA,IAAAE,UAAA,GAAAF,OAAA;AAoBA,IAAAG,UAAA,GAAAJ,sBAAA,CAAAC,OAAA;AACA,IAAAI,YAAA,GAAAL,sBAAA,CAAAC,OAAA;AAEA,IAAMK,eAAoB,GAAG,CAAC,CAAC;AAE/BA,eAAe,CAACC,YAAY,GAAG,UAACC,IAAI,EAAK;EACvC,IAAI;IACF,IAAIC,SAAS,GAAGC,YAAG,CAACC,KAAK,CAACH,IAAI,CAAC;IAE/B,IAAI,CAACC,SAAS,EAAE;MACd,OAAO,KAAK;IACd;IACA;IACA,IAAI,CAACA,SAAS,CAACG,QAAQ,EAAE;MACvBH,SAAS,GAAGC,YAAG,CAACC,KAAK,IAAAE,MAAA,CAAIC,yBAAc,EAAAD,MAAA,CAAGL,IAAI,EAAG;IACnD;IAEA,OAAOC,SAAS;EAClB,CAAC,CAAC,OAAOM,KAAK,EAAE;IACdC,oBAAW,CAACC,MAAM,CAACC,IAAI,uEAAAL,MAAA,CACiDE,KAAK,EAC5E;IAED,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAT,eAAe,CAACa,aAAa,GAAG,UAACC,KAAa,EAAK;EACjD,IAAMX,SAAS,GAAGH,eAAe,CAACC,YAAY,CAACa,KAAK,CAAC;EACrD,IAAMC,YAAY,GAAGZ,SAAS,CAACa,QAAQ,IAAIb,SAAS,CAACa,QAAQ,CAACC,QAAQ,CAACC,wBAAa,CAAC;EACrF,IAAMC,YAAY,GAChBhB,SAAS,CAACiB,QAAQ,KACjBjB,SAAS,CAACiB,QAAQ,CAACH,QAAQ,KAAAV,MAAA,CAAKc,eAAI,EAAG,IACtClB,SAAS,CAACiB,QAAQ,CAACH,QAAQ,KAAAV,MAAA,CAAKe,iBAAM,EAAG,IACzCnB,SAAS,CAACiB,QAAQ,CAACH,QAAQ,KAAAV,MAAA,CAAKgB,eAAI,EAAG,CAAC;EAE5C,OAAOR,YAAY,IAAII,YAAY;AACrC,CAAC;AAEDnB,eAAe,CAACwB,iBAAiB,GAAG,UAACV,KAAK,EAAEW,KAAK,EAAK;EACpD,IAAMC,SAAS,GAAGD,KAAK,CAACE,QAAQ,CAACC,QAAQ,CAACC,YAAY,CAACf,KAAK,CAAC;EAE7D,IAAIY,SAAS,EAAE;IACb,OAAOA,SAAS,CAACI,QAAQ,CAACC,+BAAoB,CAAC;EACjD;EAEA,OAAO,KAAK;AACd,CAAC;AAED/B,eAAe,CAACgC,QAAQ,GAAG,UAACC,SAAS,EAAK;EACxC;EACA;EACA,IAAMC,MAAM,GAAGC,uBAAY,CAACC,WAAW,CAACC,IAAI,CAACJ,SAAS,CAAC;EAEvD,OAAOC,MAAM;AACf,CAAC;AAEDlC,eAAe,CAACsC,aAAa,GAAG,UAACC,WAAW,EAAK;EAC/C,IAAMC,aAAa,GAAGL,uBAAY,CAACM,YAAY,CAACC,IAAI,CAACH,WAAW,CAAC;EAEjE,OAAOC,aAAa;AACtB,CAAC;AAEDxC,eAAe,CAAC2C,UAAU,GAAG,UAACC,WAAW,EAAK;EAC5C,IAAAC,mBAAA,GAA4B,IAAAC,0BAAkB,EAACF,WAAW,CAAC;IAApDG,IAAI,GAAAF,mBAAA,CAAJE,IAAI;IAAEC,EAAE,GAAAH,mBAAA,CAAFG,EAAE;IAAEC,OAAO,GAAAJ,mBAAA,CAAPI,OAAO;EAExB,IAAID,EAAE,IAAIE,mBAAQ,CAACR,IAAI,CAACM,EAAE,CAAC,EAAE;IAC3B,IAAID,IAAI,KAAKI,iBAAM,EAAE;MACnB,OAAO;QAACC,IAAI,EAAE,IAAI;QAAER,WAAW,EAAEI,EAAE;QAAEC,OAAO,EAAPA;MAAO,CAAC;IAC/C;IACA,IAAIF,IAAI,KAAKM,mBAAQ,EAAE;MACrB,OAAO;QAACC,MAAM,EAAE,IAAI;QAAEV,WAAW,EAAEI,EAAE;QAAEC,OAAO,EAAPA;MAAO,CAAC;IACjD;IAEA,OAAO,CAAC,CAAC;EACX;EAEA,OAAO,CAAC,CAAC;AACX,CAAC;AAEDjD,eAAe,CAACuD,0BAA0B,GAAG,UAACX,WAAW,EAAEnB,KAAK;EAAA,OAC9DA,KAAK,CAAC6B,MAAM,CACTE,GAAG,CAACZ,WAAW,CAAC,CAChBa,IAAI,CAAC,UAACC,GAAG,EAAK;IACb,IAAIA,GAAG,CAACC,MAAM,IAAID,GAAG,CAACC,MAAM,CAACC,MAAM,EAAE;MACnC,OAAOF,GAAG,CAACC,MAAM,CAAC,CAAC,CAAC;IACtB;IACA,MAAM,IAAIE,kBAAc,CAAC,iDAAiD,CAAC;EAC7E,CAAC,CAAC,CACDC,KAAK,CAAC,UAACC,GAAG,EAAK;IACdrD,oBAAW,CAACC,MAAM,CAACF,KAAK,gGAAAF,MAAA,CACyEwD,GAAG,OACnG;IACD,MAAMA,GAAG;EACX,CAAC,CAAC;AAAA;AAEN/D,eAAe,CAACgE,kBAAkB;EAAA,IAAAC,IAAA,OAAAC,kBAAA,CAAAC,OAAA,gBAAAC,YAAA,CAAAD,OAAA,CAAAE,IAAA,CAAG,SAAAC,QAAOC,IAAI;IAAA,IAAAxB,IAAA,EAAAtB,KAAA,EAAAmB,WAAA,EAAA4B,QAAA,EAAAd,GAAA,EAAAe,WAAA,EAAAC,KAAA,EAAAC,MAAA,EAAAC,OAAA,EAAAC,OAAA,EAAAC,eAAA;IAAA,OAAAV,YAAA,CAAAD,OAAA,CAAAY,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UACvCpC,IAAI,GAAWwB,IAAI,CAAnBxB,IAAI,EAAEtB,KAAK,GAAI8C,IAAI,CAAb9C,KAAK;UACbmB,WAAW,GAAI2B,IAAI,CAAnB3B,WAAW;UAAA,MAEZG,IAAI,KAAKqC,0BAAe;YAAAH,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,IAErBvC,WAAW;YAAAqC,QAAA,CAAAE,IAAA;YAAA;UAAA;UACd;UACAvC,WAAW,GAAG;YACZ+B,MAAM,EAAElD,KAAK,CAACE,QAAQ,CAAC0D,MAAM,CAACV,MAAM;YACpCD,KAAK,EAAEjD,KAAK,CAACE,QAAQ,CAAC0D,MAAM,CAACX;UAC/B,CAAC;UAACO,QAAA,CAAAE,IAAA;UAAA;QAAA;UAEIP,QAAO,GAAGU,8BAAmB,CAAC5C,IAAI,CAACE,WAAW,CAAC,GACjD;YAAC2C,KAAK,EAAE3C;UAAW,CAAC,GACpB;YAACI,EAAE,EAAEJ;UAAW,CAAC,EAAE;UAAAqC,QAAA,CAAAE,IAAA;UAAA,OACL1D,KAAK,CAAC6B,MAAM,CAACkC,IAAI,CAACZ,QAAO,CAAC;QAAA;UAAtClB,GAAG,GAAAuB,QAAA,CAAAQ,IAAA;UAAAhB,WAAA,GAEiBf,GAAG,CAACgC,KAAK,CAAC,CAAC,CAAC,EAAjChB,KAAK,GAAAD,WAAA,CAALC,KAAK,EAAMC,MAAM,GAAAF,WAAA,CAAVzB,EAAE;UAEd2B,MAAM,GAAG,IAAA7B,0BAAkB,EAAC6B,MAAM,CAAC,CAAC3B,EAAE;UACtC0B,KAAK,GAAG,IAAA5B,0BAAkB,EAAC4B,KAAK,CAAC,CAAC1B,EAAE;UACpCJ,WAAW,GAAG;YAAC+B,MAAM,EAANA,MAAM;YAAED,KAAK,EAALA;UAAK,CAAC;QAAC;UAAA,KAG9B3B,IAAI;YAAAkC,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,OAAAF,QAAA,CAAAU,MAAA,WACC;YACL/C,WAAW,EAAXA,WAAW;YACXG,IAAI,EAAJA;UACF,CAAC;QAAA;UAEG6B,OAAY,GAAG,CAAC,CAAC;UACjBC,OAAO,GAAG7E,eAAe,CAAC2C,UAAU,CAACC,WAAW,CAAC;UAAA,KAEnD5C,eAAe,CAACa,aAAa,CAAC+B,WAAW,CAAC;YAAAqC,QAAA,CAAAE,IAAA;YAAA;UAAA;UAC5CzE,oBAAW,CAACC,MAAM,CAACC,IAAI,CACrB,6GAA6G,CAC9G;UAEDgE,OAAO,CAAC7B,IAAI,GAAG6C,yBAAc;UAC7BhB,OAAO,CAAChC,WAAW,GAAGA,WAAW;UAACqC,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAA,KACzBnF,eAAe,CAACgC,QAAQ,CAACY,WAAW,CAAC;YAAAqC,QAAA,CAAAE,IAAA;YAAA;UAAA;UAC9CP,OAAO,CAAC7B,IAAI,GAAG8C,oBAAS;UACxBjB,OAAO,CAAChC,WAAW,GAAGA,WAAW;UAACqC,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAA,KACzBnF,eAAe,CAACsC,aAAa,CAACM,WAAW,CAAC;YAAAqC,QAAA,CAAAE,IAAA;YAAA;UAAA;UACnDP,OAAO,CAAC7B,IAAI,GAAG8C,oBAAS;UACxBjB,OAAO,CAAChC,WAAW,GAAGA,WAAW;UAACqC,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAA,KACzBnF,eAAe,CAACwB,iBAAiB,CAACoB,WAAW,EAAEnB,KAAK,CAAC;YAAAwD,QAAA,CAAAE,IAAA;YAAA;UAAA;UAC9DP,OAAO,CAAC7B,IAAI,GAAG+C,6BAAkB;UACjClB,OAAO,CAAChC,WAAW,GAAGA,WAAW;UAACqC,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAA,KACzBN,OAAO,CAACvB,MAAM;YAAA2B,QAAA,CAAAE,IAAA;YAAA;UAAA;UACvBP,OAAO,CAAC7B,IAAI,GAAG8C,oBAAS;UAAC,OAAAZ,QAAA,CAAAU,MAAA,WAElB3F,eAAe,CAACuD,0BAA0B,CAACsB,OAAO,CAACjC,WAAW,EAAEnB,KAAK,CAAC,CAACgC,IAAI,CAAC,UAACC,GAAG,EAAK;YAC1FkB,OAAO,CAAChC,WAAW,GAAGc,GAAG;;YAEzB;YACA;YACA;YACAkB,OAAO,CAACmB,cAAc,GAAG,IAAI;YAE7B,OAAOC,QAAA,CAAA7B,OAAA,CAAQ8B,OAAO,CAACrB,OAAO,CAAC;UACjC,CAAC,CAAC;QAAA;UAAA,KACOC,OAAO,CAACzB,IAAI;YAAA6B,QAAA,CAAAE,IAAA;YAAA;UAAA;UACrBP,OAAO,CAAC7B,IAAI,GAAG+C,6BAAkB;UAACb,QAAA,CAAAC,IAAA;UAAAD,QAAA,CAAAE,IAAA;UAAA,OAE1B1D,KAAK,CAACE,QAAQ,CAACC,QAAQ,CAACsE,cAAc,CAAC,UAAU,CAAC;QAAA;UAElDpB,eAAe,GAAGrD,KAAK,CAACE,QAAQ,CAACwE,YAAY,CAACC,mBAAmB,CAAC;YACtEnD,OAAO,EAAE4B,OAAO,CAAC5B,OAAO;YACxBD,EAAE,EAAE6B,OAAO,CAACjC;UACd,CAAC,CAAC;UAEFgC,OAAO,CAAChC,WAAW,GAAGkC,eAAe;UAACG,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAAF,QAAA,CAAAC,IAAA;UAAAD,QAAA,CAAAoB,EAAA,GAAApB,QAAA;UAEtCvE,oBAAW,CAACC,MAAM,CAACF,KAAK,6CAAAF,MAAA,CAAA0E,QAAA,CAAAoB,EAAA,EAAiD;UAAC,MAAApB,QAAA,CAAAoB,EAAA;QAAA;UAAApB,QAAA,CAAAE,IAAA;UAAA;QAAA;UAI5EzE,oBAAW,CAACC,MAAM,CAACC,IAAI,CACrB,oKAAoK,CACrK;UAAC,MACI,IAAIiD,kBAAc,CACtB,yHAAyH,CAC1H;QAAA;UAAA,OAAAoB,QAAA,CAAAU,MAAA,WAGIK,QAAA,CAAA7B,OAAA,CAAQ8B,OAAO,CAACrB,OAAO,CAAC;QAAA;QAAA;UAAA,OAAAK,QAAA,CAAAqB,IAAA;MAAA;IAAA,GAAAhC,OAAA;EAAA,CAChC;EAAA,iBAAAiC,EAAA;IAAA,OAAAtC,IAAA,CAAAuC,KAAA,OAAAC,SAAA;EAAA;AAAA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAzG,eAAe,CAAC0G,cAAc,GAAG,UAAC9B,OAAkD,EAAK;EAAA,IAAA+B,iBAAA,EAAAC,kBAAA;EACvF,IAAO7D,IAAI,GAAwC6B,OAAO,CAAnD7B,IAAI;IAAEH,WAAW,GAA2BgC,OAAO,CAA7ChC,WAAW;IAAEiE,QAAQ,GAAiBjC,OAAO,CAAhCiC,QAAQ;IAAEC,WAAW,GAAIlC,OAAO,CAAtBkC,WAAW;EAC/C,IAAMC,IAAS,GAAG;IAChBC,cAAc,EAAE,IAAI;IACpBC,kBAAkB,EAAE;EACtB,CAAC;EAED,QAAQlE,IAAI;IACV,KAAK8C,oBAAS;MACZkB,IAAI,CAACG,MAAM,GAAGtE,WAAW;MACzB;IACF,KAAKwC,0BAAe;MAClB2B,IAAI,CAACpC,MAAM,GAAG/B,WAAW,CAAC+B,MAAM;MAChCoC,IAAI,CAACrC,KAAK,GAAG9B,WAAW,CAAC8B,KAAK;MAC9B;IACF,KAAKyC,uBAAY;MACfJ,IAAI,CAACK,UAAU,GAAGxE,WAAW;MAC7B;IACF,KAAKkD,6BAAkB;MACrBiB,IAAI,CAACjC,eAAe,GAAGlC,WAAW;MAClC;IACF,KAAKyE,qBAAU;MACb;MACA,KAAAV,iBAAA,GAAI/D,WAAW,CAAC0E,IAAI,cAAAX,iBAAA,eAAhBA,iBAAA,CAAkBY,cAAc,EAAE;QACpCR,IAAI,CAACK,UAAU,GAAGxE,WAAW,CAAC0E,IAAI,CAACC,cAAc;MACnD,CAAC,MAAM,KAAAX,kBAAA,GAAIhE,WAAW,CAAC0E,IAAI,cAAAV,kBAAA,eAAhBA,kBAAA,CAAkB1E,MAAM,EAAE;QACnC6E,IAAI,CAACG,MAAM,GAAGtE,WAAW,CAAC0E,IAAI,CAACpF,MAAM;MACvC;MACA;IACF,KAAK0D,yBAAc;MACjBmB,IAAI,CAACS,UAAU,GAAG5E,WAAW;MAC7B;IACF,KAAK6E,yBAAc;MAAE;QACnBV,IAAI,CAACW,WAAW,GAAG9E,WAAW;QAC9B;MACF;IACA;EAAQ;EAGV,IAAIiE,QAAQ,EAAE;IACZE,IAAI,CAACF,QAAQ,GAAGA,QAAQ;EAC1B;EAEA,IAAIC,WAAW,EAAE;IACfC,IAAI,CAACY,SAAS,GAAGb,WAAW,CAAC9D,EAAE;IAC/B+D,IAAI,CAACa,iBAAiB,GAAGd,WAAW,CAACe,IAAI;EAC3C;EAEA,OAAOd,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA/G,eAAe,CAAC8H,YAAY,GAAG,UAACC,GAAW,EAAK;EAAA,IAAAC,UAAA;EAC9C,IAAMC,eAAe,GAAG,CAAC,gBAAgB,EAAE,kBAAkB,EAAE,gBAAgB,CAAC;EAChF,IAAMC,IAAI,GAAGH,GAAG,aAAHA,GAAG,wBAAAC,UAAA,GAAHD,GAAG,CAAEI,KAAK,CAAC,2BAA2B,CAAC,cAAAH,UAAA,uBAAvCA,UAAA,CAA0C,CAAC,CAAC;EAEzD,OAAOC,eAAe,CAAChH,QAAQ,CAACiH,IAAI,CAAC,GAAG,IAAI,GAAGA,IAAI;AACrD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAlI,eAAe,CAACoI,uBAAuB,GAAG,UAACxD,OAAyC,EAAK;EAAA,IAAAyD,kBAAA;EACvF,IAAOtF,IAAI,GAAiB6B,OAAO,CAA5B7B,IAAI;IAAEH,WAAW,GAAIgC,OAAO,CAAtBhC,WAAW;EAExB,IAAI0F,kBAAkB,GAAG,IAAI;EAE7B,QAAQvF,IAAI;IACV,KAAK8C,oBAAS;MACZyC,kBAAkB,GAAGtI,eAAe,CAAC8H,YAAY,CAAClF,WAAW,CAAC;MAC9D;IACF,KAAKyE,qBAAU;MACbiB,kBAAkB,IAAAD,kBAAA,GAAGzF,WAAW,CAAC0E,IAAI,cAAAe,kBAAA,uBAAhBA,kBAAA,CAAkBE,SAAS;MAChD;IACF;EAAQ;EAGV,OAAOD,kBAAkB,cAAA/H,MAAA,CAAc+H,kBAAkB,iCAA8B,IAAI;AAC7F,CAAC;AAAC,IAAAE,QAAA,GAEaxI,eAAe;AAAAyI,OAAA,CAAAtE,OAAA,GAAAqE,QAAA"}